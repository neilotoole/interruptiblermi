<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_17) on Mon Feb 01 14:13:44 EST 2010 -->
<TITLE>
org.neilja.net.interruptiblermi (Interruptible RMI Library API Documentation)
</TITLE>

<META NAME="date" CONTENT="2010-02-01">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="org.neilja.net.interruptiblermi (Interruptible RMI Library API Documentation)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../org/neilja/net/interruptiblermi/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV PACKAGE&nbsp;
&nbsp;NEXT PACKAGE</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/neilja/net/interruptiblermi/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
Package org.neilja.net.interruptiblermi
</H2>

 This package provides a mechanism for interrupting RMI calls.
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/neilja/net/interruptiblermi/InterruptibleRMISocketFactory.html" title="class in org.neilja.net.interruptiblermi">InterruptibleRMISocketFactory</A></B></TD>
<TD>Decorates RMISocketFactory to return Socket and ServerSocket instances that support interruptible
 RMI.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/neilja/net/interruptiblermi/InterruptibleRMIThreadFactory.html" title="class in org.neilja.net.interruptiblermi">InterruptibleRMIThreadFactory</A></B></TD>
<TD>ThreadFactory implementation to support interruptibility of RMI calls.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
Package org.neilja.net.interruptiblermi Description
</H2>

<P>
<p>
 This package provides a mechanism for interrupting RMI calls. An RMISocketFactory implementation
 is provided (<A HREF="../../../../org/neilja/net/interruptiblermi/InterruptibleRMISocketFactory.html" title="class in org.neilja.net.interruptiblermi"><CODE>InterruptibleRMISocketFactory</CODE></A>), as well as
 a ThreadFactory (<A HREF="../../../../org/neilja/net/interruptiblermi/InterruptibleRMIThreadFactory.html" title="class in org.neilja.net.interruptiblermi"><CODE>InterruptibleRMIThreadFactory</CODE></A>).
 
 Install the RMISocketFactory in the standard way. This can be done by the RMI server binding the
 factory when calling
 <CODE>UnicastRemoteObject.exportObject(Remote, int, RMIClientSocketFactory, RMIServerSocketFactory)</CODE>
 or by the client calling
 <CODE>RMISocketFactory.setSocketFactory(RMISocketFactory)</CODE>.
 </p>
 
 <h3>Client Side</h3>
 <p>
 From the client, use a thread from <code>InterruptibleRMIThreadFactory</code> to make RMI
 calls. Invoking <code>#interrupt()</code> on that thread will result in the RMI IO operation
 being terminated and the IO method returning.
 </p>
 
 <p>
 Typically a blocking IO call cannot be interrupted, but this limitation can be circumvented by
 directly closing the IO object (i.e. the socket). An RMI client socket object returned by
 <code>InterruptibleRMISocketFactory</code> registers with the thread instance returned by
 <code>InterruptibleRMIThreadFactory</code> when the socket is about to enter a blocking IO
 operation (and unregisters on exit of that IO operation). So, when <code>#interrupt()</code> is
 invoked, the thread has a reference to the socket object that is currently in blocking IO. The
 thread directly calls <code>#close()</code> on that socket (after sending a shutdown signal to
 the RMI server), terminating the blocking IO operation, and effectively simulating a regular
 interrupt. Note that after the interrupt, the socket is now dead, and the thread's interrupt
 status has been set.
 </p>
 
 <h3>Server Side</h3>
 <p>
 When the client interrupts the RMI call, the server RMI thread that was spawned in response to
 that RMI call is typically still alive. If the server RMI thread had been waiting for a resource,
 e.g. waiting for a lock on synchronized object such as a database row, then the thread would not
 know that the client had interupted the RMI call, and thus the "zombie" thread could acquire the
 contested resource, thus possibly denying a healthy thread access to the resource. To combat this
 situation, a mapping is maintained between server RMI threads and the RMI socket that spawned
 that thread. If the <code>#close</code> method is invoked on the server RMI socket,
 <code>Thread#interrupt</code> is called on on the zombie thread. At this point, or at any point
 that the server RMI thread can potentially acquire a contested resource, the "zombie" status of
 the thread can be tested using
 <A HREF="../../../../org/neilja/net/interruptiblermi/InterruptibleRMISocketFactory.html#isCurrentRMIServerThreadSocketAlive()"><CODE>InterruptibleRMISocketFactory.isCurrentRMIServerThreadSocketAlive()</CODE></A>.
 If this method returns true, the zombie RMI server thread should attempt to die (either by
 returning immediately or throwing an exception as appropriate to your application).
 </p>
 
 <p>
 The code snippet below shows how the server RMI thread can be a good citizen:
 
 <pre>
 while (isContestedResourceAvailable == false)
 {
        this.wait();
 
        // on wakeup
        if (InterruptibleRMISocketFactory.isCurrentRMIServerThreadSocketAlive() == false)
        {
                // this thread is a &quot;zombie&quot; thread - time to die!
                throw new RuntimeException(&quot;The RMI socket associated with this thread is not alive&quot;);
        }
 
        // otherwise, do something fun with the acquired resource...
 }
 </pre>
 
 </p>
 <p>
 However, note that closing of the RMI socket by the client does not necessarily result in the
 server RMI thread knowing that the client has closed its end of the socket (at least this is the
 case with the Sun JDK 5.0 implementation). That is, calling
 <code>myServerRMISocket.isClosed()</code> doesn't necessarily return true even after the client
 has interrupted the RMI call and invoked <code>myClientRMISocket.close()</code>. To signal
 that the client has shutdown the socket, the <code>#interrupt()</code> method on thread
 instances returned by <code>InterruptibleRMIThreadFactory</code> writes a shutdown signal (a
 byte value) to the client RMI socket's output stream before closing the socket. So when the
 zombie RMI server thread invokes
 <code>InterruptibleRMISocketFactory#isCurrentRMIServerThreadSocketAlive()</code>, that method
 checks if this byte value has been written to the thread's RMI socket, and can thus determine
 that the RMI call has indeed been interrupted.
 </p>
 
 <p>
 Note that the <A HREF="../../../../org/neilja/net/interruptiblermi/InterruptibleRMISocketFactory.html#isCurrentRMIServerThreadSocketAlive()"><CODE>InterruptibleRMISocketFactory.isCurrentRMIServerThreadSocketAlive()</CODE></A>
 method only gives useful results if called from an RMI server thread. If called from a non-RMI
 server thread, this method will always return <code>false</code>. Therefore, the
 <A HREF="../../../../org/neilja/net/interruptiblermi/InterruptibleRMISocketFactory.html#isCurrentThreadRMIServer()"><CODE>InterruptibleRMISocketFactory.isCurrentThreadRMIServer()</CODE></A>
 method is provided to determine whether the current thread is an RMI server thread (i.e. has
 been associated with an RMI server socket). This can be useful for applications where the same
 code may be executed in response to client requests or as server-side maintenance tasks.
 </p>
 
 <p>
 Therefore, the previous sample code could be re-written as follows to apply to general server threads:
 
 <pre>
 while (isContestedResourceAvailable == false)
 {
        this.wait();
 
        // on wakeup
        if (InterruptibleRMISocketFactory.isCurrentThreadRMIServer() == true &&
            InterruptibleRMISocketFactory.isCurrentRMIServerThreadSocketAlive() == false)
        {
                // this thread is a &quot;zombie&quot; thread - time to die!
                throw new RuntimeException(&quot;The RMI socket associated with this thread is not alive&quot;);
        }
 
        // otherwise, do something fun with the acquired resource...
 }
 </pre>
 </p>
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>neilotoole@apache.org</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../org/neilja/net/interruptiblermi/InterruptibleRMISocketFactory.html" title="class in org.neilja.net.interruptiblermi"><CODE>InterruptibleRMISocketFactory</CODE></A>, 
<A HREF="../../../../org/neilja/net/interruptiblermi/InterruptibleRMIThreadFactory.html" title="class in org.neilja.net.interruptiblermi"><CODE>InterruptibleRMIThreadFactory</CODE></A>, 
<CODE>Thread.interrupt()</CODE></DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../org/neilja/net/interruptiblermi/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV PACKAGE&nbsp;
&nbsp;NEXT PACKAGE</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/neilja/net/interruptiblermi/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
